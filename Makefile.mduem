# Makefile.mduem is just a "library" Makefile.  It doesn't nothing by itself.
# Note that this Makefile requires GNU make.
# Coding Rules  #{{{1
#
# - Use UPPER_CASE variables to be configured by user.
#
# - Use lower_case variables for internal use of mduem.
#
# - Use non-empty string as true and empty string as false.








# Common  #{{{1

SHELL=/bin/bash

repository_name := $(notdir $(shell pwd))
version := $(shell git describe --tags --always --dirty)
vim_script_repository_p := $(filter vim-%,$(repository_name))








# all  #{{{1

.PHONY: all
all: build








# build  #{{{1

TARGETS_ARCHIVED ?= $(shell git ls-files)
TARGETS_GENERATED ?=# Empty
TARGETS_STATIC ?=# Empty

targets_all_archived = $(sort $(targets_all_installed) $(TARGETS_ARCHIVED))
targets_all_installed = $(TARGETS_GENERATED) $(TARGETS_STATIC)




.PHONY: build
build: $(targets_all_installed)








# clean  #{{{1

.PHONY: clean
clean: clean-generated clean-junks

.PHONY: clean-generated
clean-generated:
	rm -rf $(TARGETS_GENERATED)

.PHONY: clean-junks
clean-junks:
	find -name '*~' -or -name ',*' | xargs rm -rf








# fetch-deps  #{{{1

DEPS ?=# Empty
vim_script_deps := $(if $(vim_script_repository_p),vim-vspec,)
all_deps := $(vim_script_deps) $(DEPS)

DEP_vim_vspec_URI := ../vim-vspec
DEP_vim_vspec_VERSION := 0.0.3a1


current_branch = $(shell git symbolic-ref -q HEAD | sed -e 's|^refs/heads/||')
origin_name = $(strip $(or \
                $(shell git config --get "branch.$(current_branch).remote"), \
		origin))
origin_uri = $(or $(shell git config 'remote.$(origin_name).url'),../.)
	# BUGS: This resolves "../" just once, but it's enough for usual cases.
resolve_dep_uri = $(strip $(if $(filter ../%,$(1)), \
                            $(dir $(origin_uri))$(1:../%=%), \
                            $(1)))
normalize_dep_name = $(subst -,_,$(1))
dep_raw_uri = $(DEP_$(call normalize_dep_name,$(1))_URI)

dep_uri = $(call resolve_dep_uri,$(call dep_raw_uri,$(1)))
dep_version = $(DEP_$(call normalize_dep_name,$(1))_VERSION)
dep_dir_name = $(patsubst %.git,%,$(notdir $(call dep_uri,$(1))))




.PHONY: fetch-deps
fetch-deps: $(all_deps:%=deps/,,%)

deps/,,%:
	@echo 'FETCH-DEP $*'
	@mkdir -p $(dir $@)
	@{ \
	   git clone $(call dep_uri,$*) $(dir $@)$(call dep_dir_name,$*) && \
	   cd ./$(dir $@)$(call dep_dir_name,$*) && \
	   git checkout $(call dep_version,$*); \
	 } &>$@.log
	@touch $@








# install  #{{{1
# Core  #{{{2

INSTALL_DIR ?=# Empty
ifeq '$(strip $(INSTALL_DIR))' ''
$(error Please set INSTALL_DIR)
endif

RENAME_TARGET ?= $(patsubst %,$(INSTALL_DIR)/%,$(1))
SHOULD_INSTALL_ASIS ?=# All files are version-filtered by default.




.PHONY: install
install: build


define rule_to_install_a_target  # (build_target, install_target)
install: $(2)
$(2): $(1)
	@echo 'INSTALL $(1) ==> $(2)'
	@mkdir -p '$(dir $(2))'
ifneq '$(call SHOULD_INSTALL_ASIS,$(1))' ''
	@cp '$(1)' '$(2)'
else
	@sed -e 's/@@VERSION@@/$(version)/' '$(1)' >'$(2)'
endif

endef
$(eval \
  $(foreach t, \
    $(targets_all_installed), \
    $(call rule_to_install_a_target,$(t),$(call RENAME_TARGET,$(t)))))


# This should be placed at the last to ensure that post-install is executed
# after any other rules to install.
install: post-install




# post-install  #{{{2

post_install_builtin_rules :=# Empty


ifneq '$(vim_script_repository_p)' ''
target_vim_helptags := $(call RENAME_TARGET,doc/tags)
$(target_vim_helptags): $(filter doc/%.txt,$(targets_all_installed))
	@echo 'POST-INSTALL vim helptags'
	@vim -n -N -u NONE -U NONE -e -c 'helptags $(dir $@) | qall!'

post_install_builtin_rules += $(target_vim_helptags)
endif


.PHONY: post-install
post-install: $(post_install_builtin_rules)








# pack  #{{{1

archive_basename = $(repository_name)-$(version)
archive_name = $(archive_basename).zip


.PHONY: pack
pack:
	rm -rf '$(archive_basename)' '$(archive_name)'
	$(MAKE) \
	  'INSTALL_DIR=$(archive_basename)' \
	  'targets_all_installed=$(targets_all_archived)' \
	  install
	zip -r $(archive_name) $(archive_basename)/
	rm -rf '$(archive_basename)'








# release  #{{{1

.PHONY: release
release:
	@echo 'FIXME: NIY'








# test  #{{{1

test_cases := $(patsubst %.expected,%, \
                $(shell git ls-files test/ | grep '\.expected$$'))




.PHONY: test
test: test/,ok

test/,ok: $(test_cases:test/%=test/,%.ok)
	@echo 'ALL TESTS PASSED.'
	@touch $@

test/,%.ok: test/,%.diff
	@echo -n 'TEST: $< ... '
	@if ! [ -s test/,%.diff ]; then \
	   echo 'OK'; \
	 else \
	   echo 'FAILED'; \
	   cat $<; \
	   echo 'END'; \
	   false; \
	 fi
	@touch $@

test/,%.diff: test/%.expected test/,%.output
	-@diff -u $^ >$@

test/,%.output: test/%.input








# __END__  #{{{1
# vim: foldmethod=marker
