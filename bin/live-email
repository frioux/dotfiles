#!/usr/bin/env python3

from imaplib import IMAP4_SSL
from netrc import netrc
from email import message_from_bytes
from argparse import ArgumentParser
from email.header import decode_header, make_header
from re import sub

parser = ArgumentParser(description='Check email')
parser.add_argument('-n', '--count', dest='count', action='store',
                   default=1, type=int,
                   help='How many messages to show')

parser.add_argument('--body', dest='content_type', action='store',
                   help='Which (if any) body to show')

parser.add_argument('--header', dest='header', action='store',
                   default='subject',
                   help='Which (if any) header to show')

parser.add_argument('-i', '--id', dest='id', action='store',
                   help='Which (if any) message to show')

args = parser.parse_args()

conn = IMAP4_SSL('imap.gmail.com')
auth = netrc().hosts['imap.gmail.com']

conn.login(auth[0], auth[2])
conn.select()

def handle_mail(num, message):
    if args.content_type:
        for part in message.walk():
            if part.get_content_type() == args.content_type:
                # why does this look like double decoding?
                print(part.get_payload(decode=True).decode("utf-8"))
    else:
        header = message.get(args.header)
        # this is stupid.
        decoded_header = str(make_header(decode_header(header)))
        # this is stupid
        unfolded_header = sub('[\r\n]', '', decoded_header)
        # why do I have to cast to int?  shouldn't %i do that?
        print("%i: %s" % (int(num), unfolded_header))

if args.id:
    typ, data = conn.fetch(args.id, '(BODY.PEEK[])')
    email = message_from_bytes(data[0][1])
    handle_mail(args.id, email)
else:
    typ, data = conn.search(None, 'ALL')
    # wow, look at all this casting
    first = int(data[0].split()[-1])
    last = int(first) - args.count + 1
    message_set = str(str(first) + ":" + str(last))
    typ, data = conn.fetch(message_set, '(BODY.PEEK[])')
    for m in reversed(data):
        # why is the last one not a tuple like the rest?  who knows.
        if len(m) != 2:
            continue
        num = m[0].split(b' ')[0]
        email = message_from_bytes(m[1])
        handle_mail(int(num), email)

conn.close()
conn.logout()
